// Wrapper script to start all the frontend and backend servers.

// Files to watch for the backend server
const WATCH = [
	// server crate
	'tango-srv',
];

// Main configuration file.
const CONFIG = './app.config.js';

// Cargo command.
const CARGO = 'cargo';

// Trigger file name.
const TRIGGER = '.serve-trigger';

//----------------------------------------------------------------------------//

// load the main configuration
const { host = 'localhost', port = 0 } = require(CONFIG);

console.log(``);
console.log(`================================================================`);
console.log(`Starting development bound to ${host}:${port}`);
console.log(`================================================================`);
console.log(``);

const root = __dirname;

const fs = require('fs');
const path = require('path');
const { spawn } = require('child_process');

const trigger_file = path.join(root, TRIGGER);

fs.writeFileSync(trigger_file, 'trigger file for serve.js -- autogenerated');

// Watches the main Rust source files and touches the `.trigger` file if
// successful.
start(CARGO, [
	// runs cargo-watch, this must be installed in the system
	'watch',
	// list of input files to watch
	...WATCH.flatMap((input) => ['-w', input]),
	// run a check on change
	'--postpone',
	'-x',
	'check',
	// touch the trigger file if successful
	'-s',
	`touch ${trigger_file}`,
]);

// Watches the `.trigger` file and restarts the application on change.
//
// Uses `systemfd` to bind the socket and provide to the application. This
// prevents losing connections on restart.
start('systemfd', [
	'--no-pid',
	'-s',
	// bind to a random port, we'll proxy this using web-dev-server
	'http::0',
	'--',
	// runs cargo watch
	'cargo',
	'watch',
	'--no-gitignore',
	'-w',
	`${trigger_file}`,
	'-x',
	'run',
]);

let webpackStarted = false;

const startWebpack = async (apiPort) => {
	webpackStarted = true;

	const webpack = require('webpack');
	const webpackDevServer = require('webpack-dev-server');
	const webpackConfig = require('./webpack.config')({ server: true, host, port, api: apiPort });

	const compiler = webpack(webpackConfig);
	const devServerOptions = { ...webpackConfig.devServer };
	const server = new webpackDevServer(devServerOptions, compiler);

	await server.start();
};

function start(command, args) {
	const cmd = spawn(command, args, {
		stdio: ['pipe', 'pipe', 'pipe'],
		env: { CARGO_TERM_COLOR: 'always', ...process.env },
	});
	cmd.stdout.on('data', (data) => {
		const text = data.toString();
		checkServerStartPort(text);
		process.stdout.write(text);
	});
	cmd.stderr.on('data', (data) => {
		const text = data.toString();
		checkServerStartPort(text);
		process.stderr.write(text);
	});
	return cmd;
}

function checkServerStartPort(text) {
	if (!webpackStarted) {
		const match = /server-start-port=(\d+)/.exec(text);
		if (match) {
			startWebpack(+match[1]);
		}
	}
}
